######################################################################
#
# Copyright (c) 2024 ETHZ Autonomous Systems Lab. All rights reserved.
#
######################################################################

from datetime import datetime
from pathlib import Path

def generate_table_top(scenarios):
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    header = f"% DO NOT MODIFY, AUTOGENERATED AT {current_time}\n"
    header += "\\renewcommand{\\thetable}{\\arabic{table}}\n\\captionsetup[table]{labelformat=simple, labelsep=colon, name=Tab.}\n"
    header += "\\begin{table*}[t]\n\\centering\n\\sisetup{detect-all}\n\\NewDocumentCommand{\\B}{}{\\fontseries{b}\\selectfont}\n"
    
    # Define the custom underline command
    header += (
        "\\def\\Decimal{.000}% Corresponds to the \".2\" of \"table-format\"\n"
        "\\def\\Uline#1{\\Ulinehelp#1 }\n"
        "\\def\\Ulinehelp#1.#2 {%\n"
        "  #1.#2\\setbox0=\\hbox{#1\\Decimal}\\hspace{-\\wd0}{\\if\\relax#2\\relax%\n"
        "    \\uline{\\phantom{#1.0}}\\else\\uline{\\phantom{#1.#2}}\\fi}%\n}\n"
    )

    column_format = "\n@{}\nl\n" + "".join([f"S[table-format=2.3]\nS[table-format=2.3]\nS[table-format=2.3]\n" for _ in scenarios]) + "@{}\n"
    header += f"\\begin{{tabular}}{{{column_format}}}\n\\toprule\n"

    scenario_headers = " & " + " & ".join([f"\\multicolumn{{3}}{{c}}{{{scenario}}}" for scenario in scenarios]) + " \\\\\n"
    metric_headers = " ".join([f"\\cmidrule(lr){{{3*i+2}-{3*i+4}}}" for i in range(len(scenarios))]) + "\n"
    metrics = "Models & " + " & ".join(["{AbsRel $(\\downarrow)$} & {$\\delta_1 (\\uparrow)$} & {RMSE $(\\downarrow)$}" for _ in scenarios]) + " \\\\\n\\midrule\n"

    return header + scenario_headers + metric_headers + metrics

def generate_table_bottom():
    return "\\bottomrule\n\\end{tabular}\n\\label{tab:results}\\caption{Comparison of metric and scaled relative Depth Anything V2 \\cite{depthanythingv2} with our approach. The suffix -S and -B indicate the pre-trained network size, small and base respectively. The best values are in bold, and the second-best values are underlined.}\n\\end{table*}"

def get_best_values(result_dict, scenarios):
    num_scenarios = len(scenarios)

    # Initialize best and second-best values for `AbsRel`, `d1`, and `RMSE`
    best_abs_rel = [float('inf')] * num_scenarios
    second_best_abs_rel = [float('inf')] * num_scenarios
    best_d1 = [-float('inf')] * num_scenarios
    second_best_d1 = [-float('inf')] * num_scenarios
    best_rmse = [float('inf')] * num_scenarios
    second_best_rmse = [float('inf')] * num_scenarios

    # Iterate through each scenario
    for j, scenario in enumerate(scenarios):
        for result in result_dict[scenario]:
            abs_rel = result['abs_rel']
            d1 = result['d1']
            rmse = result['rmse']

            # Update best and second-best for AbsRel
            if abs_rel < best_abs_rel[j]:
                second_best_abs_rel[j] = best_abs_rel[j]
                best_abs_rel[j] = abs_rel
            elif abs_rel < second_best_abs_rel[j]:
                second_best_abs_rel[j] = abs_rel

            # Update best and second-best for d1
            if d1 > best_d1[j]:
                second_best_d1[j] = best_d1[j]
                best_d1[j] = d1
            elif d1 > second_best_d1[j]:
                second_best_d1[j] = d1

            # Update best and second-best for RMSE
            if rmse < best_rmse[j]:
                second_best_rmse[j] = best_rmse[j]
                best_rmse[j] = rmse
            elif rmse < second_best_rmse[j]:
                second_best_rmse[j] = rmse

    return best_abs_rel, second_best_abs_rel, best_d1, second_best_d1, best_rmse, second_best_rmse

def get_model_lines(result_dict, scenarios):
    results_table_template_models_line = "{} " + " ".join(["& {} & {} & {}" for _ in range(len(scenarios))]) + " \\\\\n"

    best_abs_rel, second_best_abs_rel, best_d1, second_best_d1, best_rmse, second_best_rmse = get_best_values(result_dict, scenarios)

    model_lines = []
    methods = [result['method'] for result in result_dict[scenarios[0]]]

    for i, method in enumerate(methods):
        metric_list = [method]
        for j, scenario in enumerate(scenarios):
            abs_rel = result_dict[scenario][i]['abs_rel']
            d1 = result_dict[scenario][i]['d1']
            rmse = result_dict[scenario][i]['rmse']

            # Mark best and second-best values with \B and \Uline respectively
            if abs_rel == best_abs_rel[j]:
                abs_rel = "\\B " + f"{abs_rel:.3f}"
            elif abs_rel == second_best_abs_rel[j]:
                abs_rel = "\\Uline " + f"{abs_rel:.3f}"
            else:
                abs_rel = f"{abs_rel:.3f}"

            if d1 == best_d1[j]:
                d1 = "\\B " + f"{d1:.3f}"
            elif d1 == second_best_d1[j]:
                d1 = "\\Uline " + f"{d1:.3f}"
            else:
                d1 = f"{d1:.3f}"

            if rmse == best_rmse[j]:
                rmse = "\\B " + f"{rmse:.3f}"
            elif rmse == second_best_rmse[j]:
                rmse = "\\Uline " + f"{rmse:.3f}"
            else:
                rmse = f"{rmse:.3f}"

            metric_list.append(abs_rel)
            metric_list.append(d1)
            metric_list.append(rmse)

        line = results_table_template_models_line.format(*metric_list)
        model_lines.append(line)

    return model_lines

def generate_tables(output_dir, result_dict):
    scenarios = list(result_dict.keys())

    results_table = generate_table_top(scenarios)
    results_table += "".join(get_model_lines(result_dict, scenarios))
    results_table += generate_table_bottom()

    results_dir = Path(output_dir) / 'results'
    results_dir.mkdir(exist_ok=True)
    filename = results_dir / 'results_table0.tex'
    with filename.open('w') as f:
        f.write(results_table)
